import { NextRequest, NextResponse } from "next/server";
import { put } from "@vercel/blob";
import { auth } from "@clerk/nextjs/server";
import sharp from "sharp";
import dedent from "dedent";
import * as falStorage from "@fal-ai/serverless-client";
import { db } from "@/lib/db";
import { participants } from "@/lib/schema";
import { eq } from "drizzle-orm";

falStorage.config({
  credentials: process.env.FAL_API_KEY,
});

export async function POST(request: NextRequest) {
  const { userId } = await auth();
  if (!userId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  if (!db) {
    return NextResponse.json({ error: "Database not configured" }, { status: 500 });
  }

  // Check current count
  const participant = await db.query.participants.findFirst({
    where: eq(participants.clerkUserId, userId),
  });

  if (!participant) {
    return NextResponse.json({ error: "Participant not found" }, { status: 404 });
  }

  const currentImages = participant.generatedProfileImages || [];
  if (currentImages.length >= 3) {
    return NextResponse.json({ 
      error: "Limit reached", 
      message: "Has alcanzado el límite de 3 intentos de generación." 
    }, { status: 400 });
  }

  try {
    const formData = await request.formData();
    const file = formData.get("file") as File;

    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    if (!file.type.startsWith("image/")) {
      return NextResponse.json({ error: "File must be an image" }, { status: 400 });
    }

    if (file.size > 5 * 1024 * 1024) {
      return NextResponse.json({ error: "File size must be less than 5MB" }, { status: 400 });
    }

    // Upload original image
    const filename = `profile-photos/${userId}-${Date.now()}.${file.name.split(".").pop()}`;
    const blob = await put(filename, file, {
      access: "public",
      addRandomSuffix: false,
    });

    // Generate Pixel Art
    const prompt = dedent`
      8-bit pixel-art portrait, chest-up view. Use a simple solid background for easy cutout. Apply flat grayscale shading with four tones. Style should be printed, cartoonish, anime inspired, and cute tender soft. Preserve the facial structure. The character should fit entirely within the frame, with no labels or text. If the image appears too large, zoom out to ensure the full figure fits in the frame.
     IMPORTANT: Maintain a 9:16 aspect ratio. Sometimes the image may be narrow, so ensure the final result has the correct proportions.
    If the image is incomplete, the body should still be visible and the head centered like a proper portrait, zooming out when needed. Make sure the final output is 9:16.
    `;

    const pixelArtResult = (await falStorage.subscribe(
      "fal-ai/qwen-image-edit",
      {
        input: {
          prompt,
          image_url: blob.url,
        },
      },
    )) as {
      data?: { images?: Array<{ url: string }>; image?: { url: string } };
      images?: Array<{ url: string }>;
      image?: { url: string };
    };

    let pixelArtImageUrl: string | undefined;

    if (
      pixelArtResult.data?.images &&
      Array.isArray(pixelArtResult.data.images) &&
      pixelArtResult.data.images.length > 0
    ) {
      pixelArtImageUrl = pixelArtResult.data.images[0].url;
    } else if (
      pixelArtResult.images &&
      Array.isArray(pixelArtResult.images) &&
      pixelArtResult.images.length > 0
    ) {
      pixelArtImageUrl = pixelArtResult.images[0].url;
    } else if (pixelArtResult.data?.image?.url) {
      pixelArtImageUrl = pixelArtResult.data.image.url;
    } else if (pixelArtResult.image?.url) {
      pixelArtImageUrl = pixelArtResult.image.url;
    }

    if (!pixelArtImageUrl) {
      throw new Error("No pixel art generated by FAL AI");
    }

    // Remove Background
    const bgRemovalResult = (await falStorage.subscribe("fal-ai/birefnet/v2", {
      input: {
        image_url: pixelArtImageUrl,
      },
    })) as { data?: { image?: { url: string } }; image?: { url: string } };

    let transparentImageUrl: string | undefined;

    if (bgRemovalResult.data?.image?.url) {
      transparentImageUrl = bgRemovalResult.data.image.url;
    } else if (bgRemovalResult.image?.url) {
      transparentImageUrl = bgRemovalResult.image.url;
    } else {
      transparentImageUrl = pixelArtImageUrl;
    }

    const finalPixelArtUrl = transparentImageUrl || pixelArtImageUrl;

    // Process with Sharp (Grayscale + Resize)
    const pixelArtResponse = await fetch(finalPixelArtUrl);
    const pixelArtBuffer = Buffer.from(await pixelArtResponse.arrayBuffer());

    const processedPixelArt = await sharp(pixelArtBuffer)
      .resize(574, 1020, { fit: "inside" })
      .grayscale()
      .png()
      .toBuffer();

    const timestamp = Date.now();
    const avatarBlobResult = await put(
      `ai-profile-photos/${participant.id}-${timestamp}.png`,
      processedPixelArt,
      { access: "public", contentType: "image/png" },
    );

    // Update participant with new image
    const newImages = [...currentImages, avatarBlobResult.url];
    await db.update(participants)
      .set({ generatedProfileImages: newImages })
      .where(eq(participants.clerkUserId, userId));

    return NextResponse.json({
      url: avatarBlobResult.url,
      prompt: "Pixel Art Portrait",
      description: "Generated Pixel Art Portrait",
    });

  } catch (error) {
    console.error("Error generating avatar:", error);
    return NextResponse.json(
      {
        error: "Failed to generate avatar",
        details: error instanceof Error ? error.message : "Unknown error occurred",
      },
      { status: 500 },
    );
  }
}
