import { NextRequest, NextResponse } from "next/server";
import { after } from "next/server";
import { put } from "@vercel/blob";
import { auth } from "@clerk/nextjs/server";
import sharp from "sharp";
import dedent from "dedent";
import * as falStorage from "@fal-ai/serverless-client";
import { db } from "@/lib/db";
import { participants } from "@/lib/schema";
import { eq } from "drizzle-orm";

falStorage.config({
  credentials: process.env.FAL_API_KEY,
});

async function generatePixelArt(
  participantId: string,
  profilePhotoUrl: string,
) {
  if (!db) {
    console.error("[background] Database not configured");
    return;
  }

  try {
    console.log(
      "[background] Starting pixel art generation for",
      participantId,
    );

    const prompt = dedent`
      8-bit pixel-art portrait, chest-up view. Use a simple solid background for easy cutout. Apply flat grayscale shading with four tones. Style should be printed, cartoonish, anime inspired, and cute tender soft. Preserve the facial structure. The character should fit entirely within the frame, with no labels or text. If the image appears too large, zoom out to ensure the full figure fits in the frame.
     IMPORTANT: Maintain a 9:16 aspect ratio. Sometimes the image may be narrow, so ensure the final result has the correct proportions.
    If the image is incomplete, the body should still be visible and the head centered like a proper portrait, zooming out when needed. Make sure the final output is 9:16.
    `;

    console.log("[background] Calling qwen-image-edit");
    const pixelArtResult = (await falStorage.subscribe(
      "fal-ai/qwen-image-edit",
      {
        input: {
          prompt,
          image_url: profilePhotoUrl,
        },
      },
    )) as {
      data?: { images?: Array<{ url: string }>; image?: { url: string } };
      images?: Array<{ url: string }>;
      image?: { url: string };
    };

    let pixelArtImageUrl: string | undefined;

    if (
      pixelArtResult.data?.images &&
      Array.isArray(pixelArtResult.data.images) &&
      pixelArtResult.data.images.length > 0
    ) {
      pixelArtImageUrl = pixelArtResult.data.images[0].url;
    } else if (
      pixelArtResult.images &&
      Array.isArray(pixelArtResult.images) &&
      pixelArtResult.images.length > 0
    ) {
      pixelArtImageUrl = pixelArtResult.images[0].url;
    } else if (pixelArtResult.data?.image?.url) {
      pixelArtImageUrl = pixelArtResult.data.image.url;
    } else if (pixelArtResult.image?.url) {
      pixelArtImageUrl = pixelArtResult.image.url;
    }

    if (!pixelArtImageUrl) {
      console.error("[background] Could not find image URL in result");
      throw new Error("No pixel art generated by FAL AI");
    }

    console.log("[background] Pixel art generated:", pixelArtImageUrl);
    console.log("[background] Removing background from pixel art");

    interface QueueUpdate {
      status: string;
      logs?: Array<{ message: string }>;
    }

    const bgRemovalResult = (await falStorage.subscribe("fal-ai/birefnet/v2", {
      input: {
        image_url: pixelArtImageUrl,
      },
      logs: true,
      onQueueUpdate: (update: QueueUpdate) => {
        if (update.status === "IN_PROGRESS" && update.logs) {
          update.logs.map((log) => log.message).forEach(console.log);
        }
      },
    })) as { data?: { image?: { url: string } }; image?: { url: string } };

    let transparentImageUrl: string | undefined;

    if (bgRemovalResult.data?.image?.url) {
      transparentImageUrl = bgRemovalResult.data.image.url;
    } else if (bgRemovalResult.image?.url) {
      transparentImageUrl = bgRemovalResult.image.url;
    } else {
      console.warn("[background] Could not remove background, using original");
      transparentImageUrl = pixelArtImageUrl;
    }

    const finalPixelArtUrl = transparentImageUrl || pixelArtImageUrl;

    console.log("[background] Processing and uploading pixel art");

    const pixelArtResponse = await fetch(finalPixelArtUrl);
    const pixelArtBuffer = Buffer.from(await pixelArtResponse.arrayBuffer());

    const processedPixelArt = await sharp(pixelArtBuffer)
      .resize(574, 1020, { fit: "inside" })
      .grayscale()
      .png()
      .toBuffer();

    const timestamp = Date.now();
    const avatarBlobResult = await put(
      `ai-profile-photos/${participantId}-${timestamp}.png`,
      processedPixelArt,
      { access: "public", contentType: "image/png" },
    );

    console.log("[background] Pixel art uploaded:", avatarBlobResult.url);

    await db
      .update(participants)
      .set({
        profilePhotoAiUrl: avatarBlobResult.url,
        updatedAt: new Date(),
      })
      .where(eq(participants.id, participantId));

    console.log("[background] Pixel art generation completed");
  } catch (error) {
    console.error("[background] Error in pixel art generation:", error);
  }
}

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth();

    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (!db) {
      return NextResponse.json(
        { error: "Database not configured" },
        { status: 500 },
      );
    }

    const formData = await request.formData();
    const file = formData.get("file") as File;

    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    if (!file.type.startsWith("image/")) {
      return NextResponse.json(
        { error: "File must be an image" },
        { status: 400 },
      );
    }

    if (file.size > 5 * 1024 * 1024) {
      return NextResponse.json(
        { error: "File size must be less than 5MB" },
        { status: 400 },
      );
    }

    const participant = await db.query.participants.findFirst({
      where: eq(participants.clerkUserId, userId),
    });

    if (!participant) {
      return NextResponse.json(
        { error: "Participant not found" },
        { status: 404 },
      );
    }

    const filename = `profile-photos/${userId}-${Date.now()}.${file.name.split(".").pop()}`;

    const blob = await put(filename, file, {
      access: "public",
      addRandomSuffix: false,
    });

    await db
      .update(participants)
      .set({
        profilePhotoUrl: blob.url,
        updatedAt: new Date(),
      })
      .where(eq(participants.id, participant.id));

    after(() => generatePixelArt(participant.id, blob.url));

    return NextResponse.json({
      url: blob.url,
      filename: blob.pathname,
    });
  } catch (error) {
    console.error("Error uploading photo:", error);
    return NextResponse.json(
      { error: "Failed to upload photo" },
      { status: 500 },
    );
  }
}
