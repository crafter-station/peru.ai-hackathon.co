import { NextRequest, NextResponse } from "next/server";
import { after } from "next/server";
import { put } from "@vercel/blob";
import { auth } from "@clerk/nextjs/server";
import sharp from "sharp";
import path from "path";
import fs from "fs/promises";
import QRCode from "qrcode";
import satori from "satori";
import dedent from "dedent";
import * as falStorage from "@fal-ai/serverless-client";
import { db } from "@/lib/db";
import { participants } from "@/lib/schema";
import { eq, sql } from "drizzle-orm";

falStorage.config({
  credentials: process.env.FAL_API_KEY,
});

let fontsCache: { regular: Buffer; bold: Buffer } | null = null;

async function getFonts() {
  if (!fontsCache) {
    const [regular, bold] = await Promise.all([
      fs.readFile(
        path.join(
          process.cwd(),
          "app/fonts/Adelle Mono/AdelleMono-Regular.ttf",
        ),
      ),
      fs.readFile(
        path.join(process.cwd(), "app/fonts/Adelle Mono/AdelleMono-Bold.ttf"),
      ),
    ]);
    fontsCache = { regular, bold };
  }
  return fontsCache;
}

const BADGE_CONFIG = {
  profilePicture: {
    x: 130,
    y: 393,
    width: 574,
    height: 574,
  },
  participantNumber: {
    x: 150.8021863612701,
    y: 313.34721499219154,
    fontSize: 32,
    color: "rgba(246, 246, 246, 0.35)",
  },
  participantNumber2: {
    x: 150.8021863612701,
    y: 1001.5543987506467,
    fontSize: 32,
    color: "rgba(246, 246, 246, 0.35)",
  },
  firstName: {
    x: 324.5300849661869,
    y: 1199.0579656293544,
  },
  lastName: {
    x: 324.5300849661869,
    y: 1259.0579656293544,
  },
  role: {
    x: 324.5300849661869,
    y: 1299.0579656293544,
  },
  qrCode: {
    x: 115.5300849661869,
    y: 1139.0579656293544,
    width: 179,
    height: 179,
  },
};

async function generateAiAvatarAndBadge(
  participantId: string,
  profilePhotoUrl: string,
) {
  if (!db) {
    console.error("[background] Database not configured");
    return;
  }

  try {
    console.log("[background] Starting AI avatar generation for", participantId);

    const prompt = dedent`
      8-bit pixel-art portrait, chest-up view. Use a simple solid background for easy cutout. Apply flat grayscale shading with four tones. Style should be printed, cartoonish, anime inspired, and cute tender soft. Preserve the facial structure. The character should fit entirely within the frame, with no labels or text. If the image appears too large, zoom out to ensure the full figure fits in the frame.
     IMPORTANT: Maintain a 9:16 aspect ratio. Sometimes the image may be narrow, so ensure the final result has the correct proportions.
    If the image is incomplete, the body should still be visible and the head centered like a proper portrait, zooming out when needed. Make sure the final output is 9:16.
    `;

    console.log("[background] Calling qwen-image-edit");
    const pixelArtResult = (await falStorage.subscribe(
      "fal-ai/qwen-image-edit",
      {
        input: {
          prompt,
          image_url: profilePhotoUrl,
        },
      },
    )) as {
      data?: { images?: Array<{ url: string }>; image?: { url: string } };
      images?: Array<{ url: string }>;
      image?: { url: string };
    };

    let pixelArtImageUrl: string | undefined;

    if (
      pixelArtResult.data?.images &&
      Array.isArray(pixelArtResult.data.images) &&
      pixelArtResult.data.images.length > 0
    ) {
      pixelArtImageUrl = pixelArtResult.data.images[0].url;
    } else if (
      pixelArtResult.images &&
      Array.isArray(pixelArtResult.images) &&
      pixelArtResult.images.length > 0
    ) {
      pixelArtImageUrl = pixelArtResult.images[0].url;
    } else if (pixelArtResult.data?.image?.url) {
      pixelArtImageUrl = pixelArtResult.data.image.url;
    } else if (pixelArtResult.image?.url) {
      pixelArtImageUrl = pixelArtResult.image.url;
    }

    if (!pixelArtImageUrl) {
      console.error("[background] Could not find image URL in result");
      throw new Error("No AI avatar generated by FAL AI");
    }

    console.log("[background] AI avatar generated:", pixelArtImageUrl);
    console.log("[background] Removing background from AI avatar");

    interface QueueUpdate {
      status: string;
      logs?: Array<{ message: string }>;
    }

    const bgRemovalResult = (await falStorage.subscribe(
      "fal-ai/birefnet/v2",
      {
        input: {
          image_url: pixelArtImageUrl,
        },
        logs: true,
        onQueueUpdate: (update: QueueUpdate) => {
          if (update.status === "IN_PROGRESS" && update.logs) {
            update.logs.map((log) => log.message).forEach(console.log);
          }
        },
      },
    )) as { data?: { image?: { url: string } }; image?: { url: string } };

    let transparentImageUrl: string | undefined;

    if (bgRemovalResult.data?.image?.url) {
      transparentImageUrl = bgRemovalResult.data.image.url;
    } else if (bgRemovalResult.image?.url) {
      transparentImageUrl = bgRemovalResult.image.url;
    } else {
      console.warn("[background] Could not remove background, using original");
      transparentImageUrl = pixelArtImageUrl;
    }

    const finalPixelArtUrl = transparentImageUrl || pixelArtImageUrl;

    console.log("[background] Processing and uploading AI avatar");

    const pixelArtResponse = await fetch(finalPixelArtUrl);
    const pixelArtBuffer = Buffer.from(await pixelArtResponse.arrayBuffer());

    const processedPixelArtForProfile = await sharp(pixelArtBuffer)
      .resize(574, 1020, { fit: "inside" })
      .grayscale()
      .png()
      .toBuffer();

    const timestamp = Date.now();
    const avatarBlobResult = await put(
      `ai-profile-photos/${participantId}-${timestamp}.png`,
      processedPixelArtForProfile,
      { access: "public", contentType: "image/png" },
    );

    console.log("[background] AI avatar uploaded:", avatarBlobResult.url);

    await db
      .update(participants)
      .set({
        profilePhotoAiUrl: avatarBlobResult.url,
        updatedAt: new Date(),
      })
      .where(eq(participants.id, participantId));

    const participant = await db.query.participants.findFirst({
      where: eq(participants.id, participantId),
    });

    if (!participant) {
      console.log("[background] Participant not found");
      return;
    }

    let participantNumber = participant.participantNumber;

    if (!participantNumber) {
      const maxResult = await db
        .select({ max: sql<number>`COALESCE(MAX(participant_number), 0)` })
        .from(participants);
      
      participantNumber = (maxResult[0]?.max || 0) + 1;
      
      await db
        .update(participants)
        .set({
          participantNumber,
          updatedAt: new Date(),
        })
        .where(eq(participants.id, participantId));
      
      console.log("[background] Assigned participant number:", participantNumber);
    }

    console.log("[background] Generating badge for participant", participantNumber);

    const aiAvatarResponse = await fetch(avatarBlobResult.url);
    const aiAvatarBuffer = Buffer.from(await aiAvatarResponse.arrayBuffer());

    const processedPixelArt = await sharp(aiAvatarBuffer)
      .resize(
        BADGE_CONFIG.profilePicture.width,
        BADGE_CONFIG.profilePicture.height,
        { fit: "contain", background: { r: 0, g: 0, b: 0, alpha: 0 } },
      )
      .png()
      .toBuffer();

    let domain = "peru.ai-hackathon.co";

    switch (process.env.VERCEL_ENV) {
      case "production":
        if (process.env.VERCEL_PROJECT_PRODUCTION_URL) {
          domain = process.env.VERCEL_PROJECT_PRODUCTION_URL;
        }
        break;
      case "preview":
        if (process.env.VERCEL_BRANCH_URL) {
          domain = process.env.VERCEL_BRANCH_URL;
        }
        break;
    }

    const profileUrl = `https://${domain}/p/${participantNumber}`;

    const templatePath = path.join(
      process.cwd(),
      "public/onboarding/THC-IA HACK PE-ID-Participante.png",
    );

    const [fonts, qrCodeBuffer] = await Promise.all([
      getFonts(),
      QRCode.toBuffer(profileUrl, {
        errorCorrectionLevel: "M",
        type: "png",
        width: 60,
        margin: 0,
        color: {
          dark: "#000000",
          light: "#FFFFFF",
        },
      }),
    ]);

    const { regular: adelleMonoRegular, bold: adelleMonoBold } = fonts;

    const numberText = `#${String(participantNumber).padStart(3, "0")} * #${String(participantNumber).padStart(3, "0")} * #${String(participantNumber).padStart(3, "0")}`;
    
    const badgeWidth = 1080;
    const textStartX = BADGE_CONFIG.firstName.x;
    const padding = 60;
    const safetyMargin = 0.92;
    const maxTextWidth = (badgeWidth - textStartX - padding) * safetyMargin;
    
    const calculateOptimalFontSizeAndText = (
      text: string,
      baseFontSize: number,
      minFontSize: number,
      letterSpacing: number,
    ): { fontSize: number; text: string } => {
      if (!text) return { fontSize: baseFontSize, text: "" };
      
      const textLength = text.length;
      const letterSpacingValue = baseFontSize * letterSpacing;
      const avgCharWidth = baseFontSize + letterSpacingValue;
      const requiredWidth = textLength * avgCharWidth;
      
      if (requiredWidth <= maxTextWidth) {
        return { fontSize: baseFontSize, text };
      }
      
      const scaleFactor = maxTextWidth / requiredWidth;
      const scaledFontSize = baseFontSize * scaleFactor;
      const finalFontSize = Math.max(Math.floor(scaledFontSize), minFontSize);
      
      if (finalFontSize === minFontSize) {
        const minLetterSpacingValue = minFontSize * letterSpacing;
        const minAvgCharWidth = minFontSize + minLetterSpacingValue;
        const maxCharsAtMinSize = Math.floor(maxTextWidth / minAvgCharWidth);
        
        if (textLength > maxCharsAtMinSize) {
          const truncatedText = text.substring(0, maxCharsAtMinSize - 1) + "â€¦";
          return { fontSize: minFontSize, text: truncatedText };
        }
      }
      
      return { fontSize: finalFontSize, text };
    };
    
    const nameParts = (participant.fullName || "").trim().split(" ").filter(Boolean);
    
    let firstName = "";
    let lastName = "";
    
    if (nameParts.length === 0) {
      firstName = "";
      lastName = "";
    } else if (nameParts.length === 1) {
      firstName = nameParts[0];
      lastName = "";
    } else if (nameParts.length === 2) {
      firstName = nameParts[0];
      lastName = nameParts[1];
    } else {
      firstName = nameParts[0];
      const remainingParts = nameParts.slice(1);
      lastName = remainingParts.join(" ");
    }
    
    const baseNameFontSize = 60;
    const minNameFontSize = 45;
    const baseRoleFontSize = 40;
    const minRoleFontSize = 30;
    const letterSpacing = 0.08;
    
    const firstNameResult = calculateOptimalFontSizeAndText(
      firstName,
      baseNameFontSize,
      minNameFontSize,
      letterSpacing,
    );
    const firstNameFontSize = firstNameResult.fontSize;
    const finalFirstName = firstNameResult.text;
    
    const lastNameResult = calculateOptimalFontSizeAndText(
      lastName,
      baseNameFontSize,
      minNameFontSize,
      letterSpacing,
    );
    const lastNameFontSize = lastNameResult.fontSize;
    const finalLastName = lastNameResult.text;
    
    const roleText = participant.organization?.toUpperCase() || "HACKER";
    const roleResult = calculateOptimalFontSizeAndText(
      roleText,
      baseRoleFontSize,
      minRoleFontSize,
      letterSpacing,
    );
    const roleFontSize = roleResult.fontSize;
    const finalRoleText = roleResult.text;

    const qrCode = await sharp(qrCodeBuffer)
      .resize(BADGE_CONFIG.qrCode.width, BADGE_CONFIG.qrCode.height)
      .toBuffer();

    const numbersElement = (
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          width: "1080px",
          height: "1440px",
          position: "relative",
        }}
      >
        <div
          style={{
            position: "absolute",
            top: `${BADGE_CONFIG.participantNumber.y}px`,
            left: `${BADGE_CONFIG.participantNumber.x}px`,
            color: BADGE_CONFIG.participantNumber.color,
            fontSize: `${BADGE_CONFIG.participantNumber.fontSize}px`,
            fontFamily: "Adelle Mono",
            fontWeight: 500,
            letterSpacing: "0.34em",
            textTransform: "uppercase",
            textShadow: "0 1px 2px rgba(0, 0, 0, 0.3)",
          }}
        >
          {numberText}
        </div>
        <div
          style={{
            position: "absolute",
            top: `${BADGE_CONFIG.participantNumber2.y}px`,
            left: `${BADGE_CONFIG.participantNumber2.x}px`,
            color: BADGE_CONFIG.participantNumber2.color,
            fontSize: `${BADGE_CONFIG.participantNumber2.fontSize}px`,
            fontFamily: "Adelle Mono",
            fontWeight: 500,
            letterSpacing: "0.34em",
            textTransform: "uppercase",
            textShadow: "0 1px 2px rgba(0, 0, 0, 0.3)",
          }}
        >
          {numberText}
        </div>
      </div>
    );

    const textElement = (
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          width: "1080px",
          height: "1440px",
          position: "relative",
        }}
      >
        <div
          style={{
            position: "absolute",
            top: `${BADGE_CONFIG.firstName.y - firstNameFontSize}px`,
            left: `${BADGE_CONFIG.firstName.x}px`,
            color: "white",
            fontSize: `${firstNameFontSize}px`,
            fontFamily: "Adelle Mono",
            fontWeight: 700,
            letterSpacing: "0.08em",
            textTransform: "uppercase",
            textAlign: "left",
            maxWidth: `${maxTextWidth}px`,
            overflow: "hidden",
            whiteSpace: "nowrap",
          }}
        >
          {finalFirstName}
        </div>
        <div
          style={{
            position: "absolute",
            top: `${BADGE_CONFIG.lastName.y - lastNameFontSize}px`,
            left: `${BADGE_CONFIG.lastName.x}px`,
            color: "white",
            fontSize: `${lastNameFontSize}px`,
            fontFamily: "Adelle Mono",
            fontWeight: 700,
            letterSpacing: "0.08em",
            textTransform: "uppercase",
            textAlign: "left",
            maxWidth: `${maxTextWidth}px`,
            overflow: "hidden",
            whiteSpace: "nowrap",
          }}
        >
          {finalLastName}
        </div>
        <div
          style={{
            position: "absolute",
            top: `${BADGE_CONFIG.role.y - roleFontSize}px`,
            left: `${BADGE_CONFIG.role.x}px`,
            color: "white",
            fontSize: `${roleFontSize}px`,
            fontFamily: "Adelle Mono",
            fontWeight: 400,
            textTransform: "uppercase",
            textAlign: "left",
            maxWidth: `${maxTextWidth}px`,
            overflow: "hidden",
            whiteSpace: "nowrap",
          }}
        >
          {finalRoleText}
        </div>
      </div>
    );

    const svgNumbers = await satori(numbersElement, {
      width: 1080,
      height: 1440,
      fonts: [
        {
          name: "Adelle Mono",
          data: adelleMonoRegular,
          weight: 400,
          style: "normal",
        },
      ],
    });

    const svgText = await satori(textElement, {
      width: 1080,
      height: 1440,
      fonts: [
        {
          name: "Adelle Mono",
          data: adelleMonoRegular,
          weight: 400,
          style: "normal",
        },
        {
          name: "Adelle Mono",
          data: adelleMonoBold,
          weight: 700,
          style: "normal",
        },
      ],
    });

    const badgeBuffer = await sharp(templatePath)
      .resize(1080, 1440, { fit: "fill" })
      .composite([
        {
          input: processedPixelArt,
          top: Math.round(BADGE_CONFIG.profilePicture.y),
          left: Math.round(BADGE_CONFIG.profilePicture.x),
        },
        {
          input: Buffer.from(svgNumbers),
          top: 0,
          left: 0,
        },
        {
          input: Buffer.from(svgText),
          top: 0,
          left: 0,
        },
        {
          input: qrCode,
          top: Math.round(BADGE_CONFIG.qrCode.y),
          left: Math.round(BADGE_CONFIG.qrCode.x),
        },
      ])
      .png({ quality: 90 })
      .toBuffer();

    console.log("[background] Badge composed, uploading to Vercel Blob");

    const badgeBlobResult = await put(
      `badges/${participantId}-${timestamp}.png`,
      badgeBuffer,
      {
        access: "public",
        contentType: "image/png",
      },
    );

    console.log("[background] Badge uploaded:", badgeBlobResult.url);

    await db
      .update(participants)
      .set({
        badgeBlobUrl: badgeBlobResult.url,
        badgeGeneratedAt: new Date(),
        lastBadgeGenerationAt: new Date(),
        updatedAt: new Date(),
      })
      .where(eq(participants.id, participantId));

    console.log("[background] AI avatar and badge generation completed");
  } catch (error) {
    console.error("[background] Error in background processing:", error);
  }
}

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth();

    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (!db) {
      return NextResponse.json(
        { error: "Database not configured" },
        { status: 500 },
      );
    }

    const formData = await request.formData();
    const file = formData.get("file") as File;

    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    if (!file.type.startsWith("image/")) {
      return NextResponse.json({ error: "File must be an image" }, { status: 400 });
    }

    if (file.size > 5 * 1024 * 1024) {
      return NextResponse.json({ error: "File size must be less than 5MB" }, { status: 400 });
    }

    const participant = await db.query.participants.findFirst({
      where: eq(participants.clerkUserId, userId),
    });

    if (!participant) {
      return NextResponse.json(
        { error: "Participant not found" },
        { status: 404 },
      );
    }

    const filename = `profile-photos/${userId}-${Date.now()}.${file.name.split(".").pop()}`;

    const blob = await put(filename, file, {
      access: "public",
      addRandomSuffix: false,
    });

    await db
      .update(participants)
      .set({
        profilePhotoUrl: blob.url,
        updatedAt: new Date(),
      })
      .where(eq(participants.id, participant.id));

    after(() => generateAiAvatarAndBadge(participant.id, blob.url));

    return NextResponse.json({ 
      url: blob.url,
      filename: blob.pathname 
    });

  } catch (error) {
    console.error("Error uploading photo:", error);
    return NextResponse.json(
      { error: "Failed to upload photo" },
      { status: 500 }
    );
  }
}
