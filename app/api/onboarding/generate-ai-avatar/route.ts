import { type NextRequest, NextResponse } from "next/server";
import sharp from "sharp";
import { db } from "@/lib/db";
import { participants } from "@/lib/schema";
import { eq } from "drizzle-orm";
import { put } from "@vercel/blob";
import * as falStorage from "@fal-ai/serverless-client";
import { auth } from "@clerk/nextjs/server";
import dedent from "dedent";

falStorage.config({
  credentials: process.env.FAL_API_KEY,
});

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth();

    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (!db) {
      return NextResponse.json(
        { error: "Database not configured" },
        { status: 500 },
      );
    }

    const { profilePhotoUrl } = await request.json();

    if (!profilePhotoUrl) {
      return NextResponse.json(
        { error: "Profile photo URL required" },
        { status: 400 },
      );
    }

    const participant = await db.query.participants.findFirst({
      where: eq(participants.clerkUserId, userId),
    });

    if (!participant) {
      return NextResponse.json(
        { error: "Participant not found" },
        { status: 404 },
      );
    }

    console.log("[ai-avatar] Generating AI avatar from profile photo");

    const prompt = dedent`
      8-bit pixel-art portrait, chest-up view. Use a simple solid background for easy cutout. Apply flat grayscale shading with four tones. Style should be printed, cartoonish, anime inspired, and cute tender soft. Preserve the facial structure. The character should fit entirely within the frame, with no labels or text. If the image appears too large, zoom out to ensure the full figure fits in the frame.
     IMPORTANT: Maintain a 9:16 aspect ratio. Sometimes the image may be narrow, so ensure the final result has the correct proportions.
    If the image is incomplete, the body should still be visible and the head centered like a proper portrait, zooming out when needed. Make sure the final output is 9:16.
    `;

    console.log("[ai-avatar] Calling qwen-image-edit");
    const pixelArtResult = (await falStorage.subscribe(
      "fal-ai/qwen-image-edit",
      {
        input: {
          prompt,
          image_url: profilePhotoUrl,
        },
      },
    )) as {
      data?: { images?: Array<{ url: string }>; image?: { url: string } };
      images?: Array<{ url: string }>;
      image?: { url: string };
    };

    console.log("[ai-avatar] FAL result received");

    let pixelArtImageUrl: string | undefined;

    if (
      pixelArtResult.data?.images &&
      Array.isArray(pixelArtResult.data.images) &&
      pixelArtResult.data.images.length > 0
    ) {
      pixelArtImageUrl = pixelArtResult.data.images[0].url;
    } else if (
      pixelArtResult.images &&
      Array.isArray(pixelArtResult.images) &&
      pixelArtResult.images.length > 0
    ) {
      pixelArtImageUrl = pixelArtResult.images[0].url;
    } else if (pixelArtResult.data?.image?.url) {
      pixelArtImageUrl = pixelArtResult.data.image.url;
    } else if (pixelArtResult.image?.url) {
      pixelArtImageUrl = pixelArtResult.image.url;
    }

    if (!pixelArtImageUrl) {
      console.error("[ai-avatar] Could not find image URL in result");
      throw new Error("No AI avatar generated by FAL AI");
    }

    console.log("[ai-avatar] AI avatar generated:", pixelArtImageUrl);

    console.log("[ai-avatar] Removing background from AI avatar");

    interface QueueUpdate {
      status: string;
      logs?: Array<{ message: string }>;
    }

    const bgRemovalResult = (await falStorage.subscribe(
      "fal-ai/birefnet/v2",
      {
        input: {
          image_url: pixelArtImageUrl,
        },
        logs: true,
        onQueueUpdate: (update: QueueUpdate) => {
          if (update.status === "IN_PROGRESS" && update.logs) {
            update.logs.map((log) => log.message).forEach(console.log);
          }
        },
      },
    )) as { data?: { image?: { url: string } }; image?: { url: string } };

    let transparentImageUrl: string | undefined;

    if (bgRemovalResult.data?.image?.url) {
      transparentImageUrl = bgRemovalResult.data.image.url;
      console.log(
        "[ai-avatar] Background removed successfully:",
        transparentImageUrl,
      );
    } else if (bgRemovalResult.image?.url) {
      transparentImageUrl = bgRemovalResult.image.url;
      console.log(
        "[ai-avatar] Background removed successfully:",
        transparentImageUrl,
      );
    } else {
      console.warn(
        "[ai-avatar] Could not remove background, using original image",
      );
      transparentImageUrl = pixelArtImageUrl;
    }

    const finalPixelArtUrl = transparentImageUrl || pixelArtImageUrl;

    console.log("[ai-avatar] Processing and uploading AI avatar");

    const pixelArtResponse = await fetch(finalPixelArtUrl);
    const pixelArtBuffer = Buffer.from(await pixelArtResponse.arrayBuffer());

    const processedPixelArtForProfile = await sharp(pixelArtBuffer)
      .resize(574, 1020, { fit: "inside" })
      .grayscale()
      .png()
      .toBuffer();

    const timestamp = Date.now();
    const blobResult = await put(
      `ai-profile-photos/${participant.id}-${timestamp}.png`,
      processedPixelArtForProfile,
      { access: "public", contentType: "image/png" },
    );

    console.log("[ai-avatar] Uploaded to Vercel Blob:", blobResult.url);

    await db
      .update(participants)
      .set({
        profilePhotoAiUrl: blobResult.url,
        updatedAt: new Date(),
      })
      .where(eq(participants.id, participant.id));

    console.log("[ai-avatar] AI avatar generated successfully");

    return NextResponse.json({
      profilePhotoAiUrl: blobResult.url,
    });
  } catch (error) {
    console.error("[ai-avatar] Error generating AI avatar:", error);
    return NextResponse.json(
      {
        error: "Failed to generate AI avatar",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 },
    );
  }
}

