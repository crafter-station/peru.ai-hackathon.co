import { NextResponse } from "next/server";
import * as fal from "@fal-ai/serverless-client";
import path from "path";
import sharp from "sharp";
import fs from "fs";

fal.config({
  credentials: process.env.FAL_API_KEY,
});

function base64ToFile(base64String: string, filename = "upload.jpg"): File {
  const matches = base64String.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);

  if (!matches || matches.length !== 3) {
    throw new Error("Invalid base64 string");
  }

  const mimeType = matches[1];
  const base64Data = matches[2];

  const binaryString = atob(base64Data);
  const bytes = new Uint8Array(binaryString.length);

  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }

  return new File([bytes], filename, { type: mimeType });
}

export async function POST() {
  try {
    console.log("[badge-test-image] Starting pixel art generation with qwen-image-edit");

    const bgPath = path.join(process.cwd(), "public", "pp-bg.png");
    
    if (!fs.existsSync(bgPath)) {
      return NextResponse.json(
        { error: "Background image not found" },
        { status: 404 },
      );
    }

    const bgBuffer = await sharp(bgPath).toBuffer();
    const bgBase64 = `data:image/png;base64,${bgBuffer.toString("base64")}`;

    console.log("[badge-test-image] Converting base64 to File and uploading to fal.storage");
    const imageFile = base64ToFile(bgBase64, "test-background.png");
    const uploadedImageUrl = await fal.storage.upload(imageFile);
    console.log("[badge-test-image] Image uploaded to fal.storage:", uploadedImageUrl);

    const prompt =
      "8-bit pixel art portrait, chest-up view. Simple solid background for easy cutout. Flat grayscale shading with four tones. Printed, cartoonish, and cute. Preserve facial structure. The character should fit entirely within the frame, without labels or text.";

    console.log("[badge-test-image] Calling qwen-image-edit with uploaded image URL");
    const result = (await fal.subscribe("fal-ai/qwen-image-edit", {
      input: {
        prompt,
        image_url: uploadedImageUrl,
      },
    })) as {
      data?: { images?: Array<{ url: string }>; image?: { url: string } };
      images?: Array<{ url: string }>;
      image?: { url: string };
    };

    console.log("[badge-test-image] FAL result received");

    let imageUrl: string | undefined;

    if (result.data?.images && Array.isArray(result.data.images) && result.data.images.length > 0) {
      imageUrl = result.data.images[0].url;
      console.log("[badge-test-image] Found image in result.data.images");
    } else if (result.images && Array.isArray(result.images) && result.images.length > 0) {
      imageUrl = result.images[0].url;
      console.log("[badge-test-image] Found image in result.images");
    } else if (result.data?.image?.url) {
      imageUrl = result.data.image.url;
      console.log("[badge-test-image] Found image in result.data.image");
    } else if (result.image?.url) {
      imageUrl = result.image.url;
      console.log("[badge-test-image] Found image in result.image");
    }

    if (!imageUrl) {
      console.error("[badge-test-image] Could not find image URL in result. Available keys:", Object.keys(result as object));
      if (result.data) {
        console.error("[badge-test-image] result.data keys:", Object.keys(result.data as object));
      }
      return NextResponse.json(
        { error: "No images generated by FAL API" },
        { status: 500 },
      );
    }

    console.log("[badge-test-image] Successfully generated pixel art image:", imageUrl);

    console.log("[badge-test-image] Removing background from pixel art");
    
    interface QueueUpdate {
      status: string;
      logs?: Array<{ message: string }>;
    }
    
    const bgRemovalResult = (await fal.subscribe("fal-ai/birefnet/v2", {
      input: {
        image_url: imageUrl,
      },
      logs: true,
      onQueueUpdate: (update: QueueUpdate) => {
        if (update.status === "IN_PROGRESS" && update.logs) {
          update.logs.map((log) => log.message).forEach(console.log);
        }
      },
    })) as { data?: { image?: { url: string } }; image?: { url: string } };

    let transparentImageUrl: string | undefined;

    if (bgRemovalResult.data?.image?.url) {
      transparentImageUrl = bgRemovalResult.data.image.url;
      console.log("[badge-test-image] Background removed successfully:", transparentImageUrl);
    } else if (bgRemovalResult.image?.url) {
      transparentImageUrl = bgRemovalResult.image.url;
      console.log("[badge-test-image] Background removed successfully:", transparentImageUrl);
    } else {
      console.warn("[badge-test-image] Could not remove background, using original image");
      transparentImageUrl = imageUrl;
    }

    const finalImageUrl = transparentImageUrl || imageUrl;
    console.log("[badge-test-image] Final image URL:", finalImageUrl);

    return NextResponse.json({
      url: finalImageUrl,
    });
  } catch (error) {
    console.error("[badge-test-image] Pixel art generation failed");
    console.error("[badge-test-image] Error type:", typeof error);
    console.error("[badge-test-image] Error constructor:", error?.constructor?.name);

    const errorDetails = JSON.stringify(error, Object.getOwnPropertyNames(error), 2);
    console.error("[badge-test-image] Full error object:", errorDetails);

    if (error && typeof error === "object") {
      const err = error as Record<string, unknown>;
      console.error("[badge-test-image] Error.name:", err.name);
      console.error("[badge-test-image] Error.message:", err.message);
      console.error("[badge-test-image] Error.status:", err.status);
      console.error("[badge-test-image] Error.body:", err.body);
      console.error("[badge-test-image] Error.stack:", err.stack);
    }

    const errorMessage = error instanceof Error ? error.message : String(error);
    return NextResponse.json(
      {
        error: "Failed to generate test image",
        details: errorMessage,
      },
      { status: 500 },
    );
  }
}

